package com.pengwz.dynamic.sql2;

import com.pengwz.dynamic.sql2.core.dml.select.AbstractColumnReference;
import com.pengwz.dynamic.sql2.core.dml.select.Select;

/**
 * 核心设计原则
 * <p>
 * 1.	自动化数据库差异处理：
 * •	方言机制：框架应该具备强大的方言处理能力，根据不同数据库自动生成合适的 SQL。要支持 MySQL、Oracle、PostgreSQL、SQL Server 等常见数据库。
 * •	自动查询生成：对增删改查操作尽可能由框架自动生成 SQL，屏蔽数据库之间的差异。
 * 2.	动态数据源切换：
 * •	提供灵活的数据源管理能力，能够根据业务需求动态切换不同的数据源，并确保事务性和一致性。
 * •	多数据源支持：框架应能动态切换或平滑切换数据源，支持跨数据库的操作和事务管理。
 * 3.	高扩展性：
 * •	框架应该足够灵活，允许开发者扩展特定数据库的功能，尤其是在一些数据库特有的功能（如存储过程、序列、窗口函数）上，提供钩子或扩展点。
 * •	模块化设计，能够方便地接入新数据库类型或者定制新的方言规则。
 * 4.	智能查询构建器：
 * •	提供类似 QueryDSL 或 JPA Criteria 的查询构建器，开发者可以通过类型安全的方式构建查询，无需手写 SQL。
 * •	查询构建器应该允许嵌套条件、动态条件、分页、排序、分组等复杂操作，同时对数据库差异（如分页、表连接）自动处理。
 * 5.	事务管理和分布式事务：
 * •	支持单一数据库的事务管理，同时针对多数据源的操作引入分布式事务支持。
 * •	集成分布式事务管理器（如 Seata），确保在多个数据库之间操作时数据的一致性。
 * 6.	自动模式迁移（Schema Migration）：
 * •	提供数据库自动模式迁移工具，能够在不同数据库之间迁移表结构、索引、约束等元数据，并确保兼容性。
 * •	支持版本化的模式变更，方便自动升级和回滚。
 * <p>
 * 功能模块建议
 * <p>
 * 1.	数据库方言模块：
 * •	抽象方言接口：定义一个 Dialect 接口，包含常见的 SQL 生成方法（如分页、排序、表连接等）。
 * •	方言自动识别：根据数据库连接的元数据自动识别并加载合适的方言。
 * •	方言扩展机制：开发者可以通过实现 Dialect 接口，轻松为不支持的数据库添加新的方言支持。
 * 2.	动态查询生成模块：
 * •	通用查询生成器：类似 JPA Criteria 或 QueryDSL 的 API，通过链式调用来构建查询条件。
 * •	动态 SQL 优化：针对不同数据库优化生成的 SQL，避免性能问题（如 Oracle 中的 ROWNUM、MySQL 中的 LIMIT）。
 * 3.	数据源管理模块：
 * •	多数据源支持：提供一个强大的数据源管理器，能够动态切换数据源或者实现负载均衡。
 * •	数据源切换策略：可以根据租户、业务场景或运行时条件切换数据源。
 * •	事务管理：保证多数据源切换时事务的一致性，支持本地事务和分布式事务。
 * 4.	复杂查询和批量操作支持：
 * •	提供原生支持批量插入、更新、删除操作。
 * •	对复杂查询的优化，如嵌套子查询、多表联查、多层次分页等操作。
 * 5.	性能监控和分析：
 * •	提供内置的查询性能监控工具，支持查询日志、慢查询分析等功能，帮助开发者优化数据库访问性能。
 * •	自动生成的 SQL 可以在日志中打印，方便调试和优化。
 * 6.	多租户支持（Multi-Tenancy）：
 * •	提供多租户模式支持，可以通过不同的数据库实例、schema 或表分片实现数据隔离。
 * •	支持基于字段隔离和数据库实例隔离，方便适应不同的多租户架构。
 * 7.	API 友好性：
 * •	框架应该提供简洁且易用的 API，符合主流开发习惯，并且具有高度的灵活性，允许开发者根据需要选择高级功能。
 * •	尽量减少配置，能够通过注解或简洁的 DSL 实现业务逻辑。
 * <p>
 * 设计细节建议
 * <p>
 * 1.	领域驱动设计：采用 DDD（领域驱动设计）的思路，将业务逻辑、数据模型和持久化层紧密结合，通过聚合根、实体、值对象等方式减少开发者在数据库访问上的认知负担。
 * 2.	领域特定语言（DSL）：提供一套清晰简洁的 DSL，开发者可以通过类 SQL 语法构建查询，而不需要关心底层数据库实现。
 * 3.	缓存支持：集成缓存框架（如 Redis），提供实体缓存、查询缓存等功能，减少数据库访问压力。
 * 4.	异步和反应式支持：随着微服务和响应式架构的流行，框架应具备异步和反应式数据库访问的能力，支持基于 CompletableFuture 或 Reactor 的非阻塞查询。
 * <p>
 * 应对业务场景
 * <p>
 * 1.	标准增删改查：框架应该支持基本的 CRUD 操作，且能适配不同的数据库。
 * 2.	复杂关联查询：需要支持复杂的表关联、嵌套查询等场景，通过自动 SQL 生成或提供简单的查询 DSL。
 * 3.	数据分页和排序：内置分页、排序功能，自动适配不同数据库的分页机制（如 MySQL 的 LIMIT、Oracle 的 ROWNUM 等）。
 * 4.	历史数据或审计功能：框架可以内置审计功能，自动记录实体的创建时间、更新时间、操作者等。
 * 5.	兼容多种数据库特性：在某些场景下，可能需要支持数据库特有的功能（如 Oracle 的 sequence，PostgreSQL 的 jsonb），需要设计灵活的扩展接口，让开发者可以为特定数据库实现定制化的功能。
 * <p>
 * 未来扩展和维护
 * <p>
 * •	支持新的数据库：通过方言机制可以灵活地引入对新数据库的支持。
 * •	社区驱动发展：框架可以设计成插件化，社区或开发者可以轻松为其添加新功能或适配新的数据库。
 * <p>
 * 结论
 * <p>
 * 一个无感迁移的 ORM 框架需要具备自动适配数据库、动态数据源管理、智能查询生成、高扩展性等特性，以支持复杂业务场景并简化开发者的工作。通过关注方言、动态查询、事务和数据源管理，可以大幅降低跨数据库的开发和维护成本，实现真正的无感迁移。
 */
public class SqlContext {

    private SqlContext() {
    }

    //TODO 回头把扫描包配置作为参数传进来  比如指定扫描的数据源位置、实体类位置、是否开启实时加载表等等
    public static SqlContext createSqlContext() {
        return new SqlContext();
    }

    public AbstractColumnReference select() {
        return new Select().loadColumReference();
    }


}
